---
title: "임시 정리 / Blah blah"
date: 2022-06-06 21:55:12 +0900
categories: 임시 정리 Blah
---
# 참고 링크들 북마크에 정리
<br><br>

Destroy 지연시키는 방법
<br>

```
// Destroy 함수 실행시 초단위 인자를 전달하면 된다.
// 2초 후 Destroy
Destroy(2.0f);
```
<br>

프리팹에서의 게임 오브젝트 할당
<br>

```
에디터에서 드래그를 통해 게임 오브젝트를 할당할 때, 프리팹 내에서는 프리팹 내의 게임 오브젝트만 할당할 수 있다.

- 참고
https://onecoke.tistory.com/entry/%EC%9C%A0%EB%8B%88%ED%8B%B0-prefab%EC%97%90-%EC%98%A4%EB%B8%8C%EC%A0%9D%ED%8A%B8-%ED%95%A0%EB%8B%B9
```
<br>

곱셈이 나눗셈보다 빠른 이유
<br>

```
곱셈은 곱해지는 수를 곱하는 수의 각 자릿수에 곱해 더하면 한 번에 끝낼 수 있지만,
나눗셈은 나머지가 나누는 수보다 작아질 때까지 나머지를 기억하며 계속 빼야하기 때문이다.

- 참고
https://blog.naver.com/fah204/221573584390
```
<br>

gameObject.GetComponent() 와 Component.GetComponent() 의 차이점
<br>

```
두 함수는 완벽히 같은 동작을 수행할 뿐만 아니라, 사실 수행되는 함수도 동일하다.

유니티 공식 문서에는 Component.GetComponent() 는 게임 오브젝트에 컴포넌트가 존재할 경우 반환한다고 되어 있으며, 애초에 자신과 상관 없이 게임 오브젝트에서 컴포넌트를 찾는다는 뜻이다.

따라서, 다음과 같은 괴상한 코드도 정상적으로 작동한다.
other.transform.GetComponent<MyComponent>().gameObject.GetComponent<MyComponent>().transform.gameObject.GetComponent<MyComponent>().something = true;

transform 과 GetComponent 등은 사실 gameObject 의 멤버이지만, 자주 쓰이므로 컴포넌트에서 바로 사용할 수 있게 해놓은 것이다.
실제, GetComponent 가 구현돼 있는 부분을 보면 단순히 gameObject.GetComponent 를 프록시하여 호출하는 것을 볼 수 있다.

모든 컴포넌트는 스크립트 클래스가 인스턴스화된 객체이다.
게임 오브젝트는 컴포넌트를 담는 컨테이너이다.

게임 오브젝트와 컴토넌트는 부모, 자식 등의 상속 관계는 아니다.
에니터에서 public Transform transform 에 게임 오브젝트를 지정 가능한 이유는 유니티가 내부적으로 GetComponent()를 통해 변환해 주기 때문이다.
부모, 자식 관계가 아니기에 타입 캐스팅이 불가능하고 코드에서는 Transform tr = other.gameObject; 와 같이 사용할 수 없다.

모든 게임 오브젝트의 타입은 같지만, 컴포넌트는 각기 다른 타입을 갖는다.
모든 게임 오브젝트는 무조건 Transform 컴포넌트를 갖는다.

- 참고
https://forum.unity.com/threads/gameobject-getcomponent-vs-getcomponent.948035/
https://docs.unity3d.com/ScriptReference/MonoBehaviour.html
https://github.com/Unity-Technologies/UnityCsReference/blob/2022.2/Runtime/Export/Scripting/Component.bindings.cs
https://answers.unity.com/questions/1360282/what-is-the-difference-between-gameobjectgetcompon.html
```
<br>

GameObject 와 Component 의 부모 클래스
<br>

```
https://devbot.tistory.com/entry/%EC%9C%A0%EB%8B%88%ED%8B%B0-monobehaviour-%EC%83%81%EC%9C%84-%ED%81%B4%EB%9E%98%EC%8A%A4-%EC%A0%95%EB%A6%AC
https://skuld2000.tistory.com/25
https://we1cometomeanings.tistory.com/106
https://blog.eyas.sh/2020/10/unity-for-engineers-pt5-object-component/

- 참고
https://devbot.tistory.com/entry/%EC%9C%A0%EB%8B%88%ED%8B%B0-monobehaviour-%EC%83%81%EC%9C%84-%ED%81%B4%EB%9E%98%EC%8A%A4-%EC%A0%95%EB%A6%AC
https://skuld2000.tistory.com/25
https://we1cometomeanings.tistory.com/106
https://blog.eyas.sh/2020/10/unity-for-engineers-pt5-object-component/
```
<br>

IEnumerator
<br>

```
실행 흐름을 넘겼다가 중단된 다음 부분부터 이어서 실행할 수 있다.

public static void Main(string[] args)
{
    IEnumerator it = IE();

    Console.ReadLine();
    Console.WriteLine(it.MoveNext());
    Console.WriteLine(it.Current);

    Console.ReadLine();
    Console.WriteLine(it.MoveNext());
    Console.WriteLine(it.Current);

    Console.ReadLine();
    Console.WriteLine(it.MoveNext());
    Console.WriteLine(it.Current);

    Console.ReadLine();
    Console.WriteLine(it.MoveNext());
    Console.WriteLine(it.Current);

    Console.ReadLine();
    Console.WriteLine(it.MoveNext());
    Console.WriteLine(it.Current);
}

public static IEnumerator IE()
{
    Console.WriteLine("1");
    yield return 1;

    Console.WriteLine("2");
    yield return 2;

    Console.WriteLine("3");
    yield return 3;

    Console.WriteLine("4");
    yield return 4;

    Console.WriteLine("5");
}

- 참고
https://blog.naver.com/happybaby56/221322535793
```
<br>

```

1
True
1

2
True
2

3
True
3

4
True
4

5
False
4
```
<br>

IEnumerable?
<br>

```
일반적으로 foreach 문에 사용되며, GetEnumerator() 를 통해 IEnumerator 를 가져올 수 있다.

비표준적으로(홀수만 가져오기 등) 값을 가져오고 싶을 때는 IEnumerator 를 사용해야 한다.

- 참고
https://stackoverflow.com/questions/619564/what-is-the-difference-between-ienumerator-and-ienumerable#:~:text=An%20IEnumerator%20is%20a%20thing,method%20that%20returns%20an%20IEnumerator%20.
```
<br>

코루틴
<br>

```
StartCoroutine(MyCoroutine()); 으로 코루틴을 시작하는 것은 MyCoroutine() 에서 반환된 IEnumerator를 이용해, MoveNext() 의 결과가 false일 때까지 매 프래임마다 MoveNext()를 호출하겠다는 뜻이다.

단순히 MyCoroutine() 으로 실행한 상태에서는 코드가 시작되지 않으며, 첫 MoveNext() 를 실행해야 첫 yield return 부분까지 실행된다.

// 3초 동안은 MoveNext()를 실행하지 않는다.
yield return new WaitForSeconds(3.0f);

- 참고
https://velog.io/@uchang903/UnityCoroutine%EC%BD%94%EB%A3%A8%ED%8B%B4%EC%9D%98-%EA%B0%9C%EB%85%90%EA%B3%BC-%ED%99%9C%EC%9A%A9
https://www.csharpstudy.com/CSharp/CSharp-yield.aspx
https://postpiglet.netlify.app/posts/Coroutine-Considerationn/
```
<br>

코루틴을 시작하고 멈추는 방법
<br>

```
IEnumerator it = CoFunc();
StartCoroutine(it);
StopCoroutine(it);

Coroutine cort = StartCoroutine(CoFunc());
StopCoroutine(cort);

StartCoroutine("CoFunc");
StopCoroutine("CoFunc");

모두 멈추기
StopAllCoroutines();

조건문을 넣어 특정 조건에서 중지시킬 수도 있다.
yield break;

- 참고
https://notyu.tistory.com/62
```
<br>

코루틴을 멈추는 잘못된 방법
<br>

```
// 유니티에서는 가능하면 StartCoroutine 과 StopCoroutine 시에 전달 인자를 혼합하여 쓰지 말 것을 권장한다.
StartCoroutine(CoFunc());
StopCoroutine("CoFunc");

StartCoroutine(CoFunc());
StopCoroutine(CoFunc());

- 참고
https://notyu.tistory.com/62
```
<br>

WaitForSeconds
<br>

```
WaitForSeconds 가 시작되는 시점은 호출 직후가 아닌, 현재 프레임이 끝난 후이다.

- 참고
https://docs.unity3d.com/kr/530/ScriptReference/WaitForSeconds.html
```
